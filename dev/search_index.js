var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = StructWalk","category":"page"},{"location":"#StructWalk","page":"Home","title":"StructWalk","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StructWalk.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [StructWalk]","category":"page"},{"location":"#StructWalk.LeafNode","page":"Home","title":"StructWalk.LeafNode","text":"LeafNode(x)\n\nspecial type for marking non-leaf value as leaf. Use with prewalk.\n\nSee also: prewalk\n\n\n\n\n\n","category":"type"},{"location":"#StructWalk.WalkStyle","page":"Home","title":"StructWalk.WalkStyle","text":"Abstract type WalkStyle\n\nSubtype WalkStyle and overload walkstyle to define custom walking behaviors (constructor / children /...).\n\n\n\n\n\n","category":"type"},{"location":"#StructWalk.postwalk-Tuple{Any, Any}","page":"Home","title":"StructWalk.postwalk","text":"postwalk(f, [style = WalkStyle], x)\n\nApplies f to each node in x and return the result. f sees the leaves first and then the transformed node.\n\nExample\n\njulia> postwalk(x -> @show(x) isa Integer ? x + 1 : x, (a=2, b=(c=4, d=0)))\nx = 2\nx = 4\nx = 0\nx = (c = 5, d = 1)\nx = (a = 3, b = (c = 5, d = 1))\n(a = 3, b = (c = 5, d = 1))\n\njulia> postwalk(x -> @show(x) isa Integer ? x + 1 : x .+ 1, (3, 5))\nx = 3\nx = 5\nx = (4, 6)\n(5, 7)\n\njulia> postwalk(x -> @show(x) isa Integer ? x // 2 : x isa Tuple ? =>(x .+ 1...) : x, (3, 5))\nx = 3\nx = 5\nx = (3//2, 5//2)\n5//2 => 7//2\n\n\nSee also: prewalk\n\n\n\n\n\n","category":"method"},{"location":"#StructWalk.prewalk-Tuple{Any, Any}","page":"Home","title":"StructWalk.prewalk","text":"prewalk(f, [style = WalkStyle], x)\n\nApplies f to each node in x and return the result. f sees the node first and then the transformed leaves.\n\nNotice that it is possible it walk infinitely if you transform a node into non-leaf value.  Wrapping the non-leaf value with LeafNode(y) in f to prevent infinite walk.\n\nExample\n\njulia> prewalk(x -> @show(x) isa Integer ? x + 1 : x, (a=2, b=(c=4, d=0)))\nx = (a = 2, b = (c = 4, d = 0))\nx = 2\nx = (c = 4, d = 0)\nx = 4\nx = 0\n(a = 3, b = (c = 5, d = 1))\n\njulia> prewalk(x -> @show(x) isa Integer ? x + 1 : x .+ 1, (3, 5))\nx = (3, 5)\nx = 4\nx = 6\n(5, 7)\n\njulia> prewalk(x -> @show(x) isa Integer ? StructWalk.LeafNode(x // 2) : x isa Tuple ? =>(x .+ 1...) : x, (3, 5))\nx = (3, 5)\nx = 4\nx = 6\n2 => 3\n\n\nSee also: postwalk, LeafNode\n\n\n\n\n\n","category":"method"},{"location":"#StructWalk.walkstyle","page":"Home","title":"StructWalk.walkstyle","text":"walkstyle(::CustomWalkStyle, x::T) where {CumstomWalkStyle <: WalkStyle}\n\nShould return a tuple of length 2-3 with:\n\n1. A proper constuctor for `T`, can be `identity` if `x` isa leaf.\n2. Children of `x` in a tuple, or empty tuple `()` if `x` is a leaf.\n3. [optional] a bool indicate whether element of 2. is the actual list of children. default to `false`.\n\nFor example, since Array has 0 fieldcount, we doesn't split the value into a tuple as children.  Instead, we return (x,) as children and the extra boolean true, so it will walk/map through x  accordingly.\n\n\n\n\n\n","category":"function"},{"location":"#StructWalk.walkstyle-Tuple{Any}","page":"Home","title":"StructWalk.walkstyle","text":"walkstyle(x)\nwalkstyle(::Type{WalkStyle}, x::T) where T\n\nreturn T and a tuple all field values of x.\n\n\n\n\n\n","category":"method"}]
}
